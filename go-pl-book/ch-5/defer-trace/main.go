package main

import (
	"log"
	"os"
	"time"
)

// This program represent a clever technique which can be used while debugging or benchmarking a function perfomance time, all using defer

func main() { bigSlowOperation() }

// in a single statement, we're running two functions , one at the starting (trace()) and another after it's exit (the anonymous function returned by trace()())
func bigSlowOperation() {
	defer trace("big slow operation")() // trace() is being called imidiately, what's being defered is the returned function
	time.Sleep(time.Second * 5)
}

// trace returns another function
// we're logging when the trace function was called, and when then function returned by trace function was called
func trace(msg string) func() {
	start := time.Now()
	log.Printf("enter %s ", msg)                               // this runs when trace() is called
	return func() { log.Printf("exit %s", time.Since(start)) } // this runs when trace()() is called
}

// Another use case for defer is closing the Open files
// But special attention needs to be given to files that are being opened inside a loop

func fileOpenBad(filenames []string) {
	for _, filename := range filenames {
		file, err := os.Open(filename)
		if err != nil {
			// handle the error
		}
		defer file.Close() // NOTE : this is dangerous, since defer calls are not executed untill this entire function is done executing
		// meaning all the open files will not be closes untill the last one is closed.
		// This could lead to "File descriptor leak" (file descriptors are generated by the OS and given to the program, they're limited)
		// hence the old file descriptors always should to be closed before creating more
	}
}

// Better solution is to create a seperate function to handle the files
// instead of opening the file in this function, Open it in doFile() and use the defer call there
func fileOpenGood(filenames []string) {
	for _, filename := range filenames {
		if err := doFile(filename); err != nil {
			// handle the error
		}
	}
}

// This way we can make sure that every file that is opened, will be closed once the doFile() function exits the execution context (the callstack in Javascript )
func doFile(filename string) error {
	f, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	// process the file down here

	return nil
}
